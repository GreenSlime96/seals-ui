from enum import Enum

import logging
import time

import PyCapture2

# # supported cameras
# supported_cameras = [b'Grasshopper3 GS3-U3-120S6C']

# track the detailed part of the last error generated by a subsystem here
# we present it with a summary during error messages
last_detail = ""


def imgSetEqual(s1, s2):
    """Compare two PyCapture2.Format7ImageSettings."""
    return (s1.mode == s2.mode and s1.offsetX == s2.offsetX and
            s1.offsetY == s2.offsetY and s1.width == s2.width and
            s1.height == s2.height and s1.PixelFormat == s2.pixelFormat)


class Error(Exception):
    """An error from the camera.

    message -- a high-level description of the error
    detail -- a string with some detailed diagnostics
    """

    def __init__(self, message, detail=None):
        global last_detail

        self.message = message
        if detail:
            self.detail = detail
        else:
            self.detail = last_detail

        logging.debug('camera: Error %s %s', self.message, self.detail)

    def __str__(self):
        return '%s - %s' % (self.message, self.detail)


class Camera:
    """Talk to a USB camera with PyCapture2."""

    def __init__(self):
        """Initialise the PyCapture2 Camera."""
        self.busManager = PyCapture2.BusManager()
        self.camera = PyCapture2.Camera()

        # Declare camera modes here
        self.mode_current = None

        self.mode_preview = None
        self.mode_capture = None

    def connect(self):
        """Connect to the camera.

        If currently unattached, automatically connect to any attached
        camera. This method is called for you before any camera operation.
        """
        if not self.camera.isConnected:
            logging.debug('** camera init')
            numCams = self.busManager.getNumOfCameras()

            if numCams == 0:
                self.release()
                raise Error('No cameras detected')

            # # look for first camera matching 'Grasshopper3 GS3-U3-120S6C'
            # for i in range(numCams):
            #     try:
            #         uid = self.busManager.getCameraFromIndex(i)
            #     except PyCapture2.Fc2error:
            #         raise Error('Unable to connect to camera')
            #     else:
            #         self.camera.connect(uid)
            #         camInfo = self.camera.getCameraInfo()
            #
            #         print('Found model ', camInfo.modelName)
            #
            #         if camInfo.modelName in supported_cameras:
            #             break
            #         else:
            #             self.camera.disconnect()
            #
            # if not self.camera.isConnected:
            #     raise Error('No suitable camera found')

            try:
                uid = self.busManager.getCameraFromIndex(0)
                self.camera.connect(uid)
                self.camera.startCapture()
            except PyCapture2.Fc2error:
                raise Error('Unable to connect to camera')

            # check if PREVIEW is supported
            fmt7info, supported = self.camera.getFormat7Info(PyCapture2.
                                                             MODE.MODE_5)

            fmt7imgSet = PyCapture2.Format7ImageSettings(PyCapture2.MODE.
                                                         MODE_5, 0, 0,
                                                         fmt7info.maxWidth,
                                                         fmt7info.maxHeight,
                                                         PyCapture2.
                                                         PIXEL_FORMAT.RGB)

            fmt7pktInf, isValid = self.camera.validateFormat7Settings(fmt7imgSet)

            if not isValid:
                raise Error('Camera does not support Preview mode')

            self.mode_preview = (fmt7pktInf.recommendedBytesPerPacket, fmt7imgSet)

            logging.debug('** camera connected')
            self.ensure_mode(self.mode_preview)

    def release(self):
        """Drop the camera connection.

        Calling this method will force reconnection on the next camera
        operation.
        """
        if self.camera.isConnected:
            logging.debug('** camera shutdown')
            print('release')
            self.camera.disconnect()

    def ensure_mode(self, mode):
        if self.mode_current != mode:
            self.camera.stopCapture()
            self.camera.setFormat7ConfigurationPacket(*mode)
            self.mode_current = mode
            self.camera.startCapture()

    def preview(self):
        """Connect and capture a preview frame.

        Return the preview as a(data, length) tuple pointing to a memory
        area containing a jpeg-compressed image. The data poiner is only valid
        until the next call to preview().
        Preview can fail for short periods. If you get None back, try again
        later.
        """
        logging.debug('** camera preview')

        self.connect()
        self.ensure_mode(self.mode_preview)

        retval = self.camera.retrieveBuffer()

        logging.debug('preview: frame at addr %d, length %d', id(retval),
                      retval.getDataSize())

        return retval
